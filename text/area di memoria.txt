- area codice 
- area dati globali
- area stack:
    | main |
    | f    | man mano che main richiama una funzione l'area di memoria delle variabili locali viene "impillata" nell'area stack.
             Quando viene eseguita l'area di memoria viene deallocata.
L'area stack potrebbe diventare "satura" dalle funzione stesse ma questo il compilatore non lo sa.

---

inf f(int a, int b)
{
    return(a+b);
}

invocazione:
funzionale x = f(a,b)

procedurale ? f(a,b)

---

void if(int a, int b)
{
    return(a + b) NO
}
 
funzionale NO x = f(a,b) ERRORE

procedurale f(a,b)

---

int main()
{
    int areaa;
    a = f(a);

    return 0; std ok
}

main colloquia con il sistema operataivo per avviare il programma


int f(int d)
{
    exit; funzione del sistema operativo, non è un normale return, exit chiede brutalmente al so di intervenire e di bloccare l'intera esecuzione del programma
}

---

passaggio parametri per indirizzo "simulato"
- parametro formale: si aspetta un indirzzo: tipo puntatore (*x)
- parametro attuale passa un indirizzo: tipo indirizzo(&)
- parametro deve essere utilizzzato all'interno delle funzioni tramite la derenziazione (es. *x = 10) - accesso via indirizzo;

inr main()
{
    int a = 10; 
    int b = 11;
    scambia(&a, &b);
}

void scambia(int *x, int *y)
{
    int temp;
    temp = *x;
    *x = *y;
    *y = temp;
}

x y contenitori di puntatori di numeri interi

---
array: passaggio dell'indirzzo del primo elemento del vettore


&vet[1];
vet = &v[0];
char *S è uguale a char s[];

parametri formali:
inf f(int *a) contenitore di un indirizzo di un elemento di tipo integer

int f(int a[]) - indirizzo di un elemento del vettore (in genere il primo)
