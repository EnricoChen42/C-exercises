PROGRAMMA
#direttive
global declarative part (optional)

function definition (optional):
y = f(x)
type identifier(parametri formali)
{local declarative part executive-part}

int main() {executive-part} -> la funzione predefinita da cui parte la prima istruzione eseguibile; 
int restituisce un valore integeral sistema operativo
------------

int a = 10;
int b = 11;
float c = 12.5;

int sum(int x, int y)
{
    int temp;
    temp = x + y;
    return temp
}

int main()
{
    if(sum(a,b) > 20);
        printf();
    else
        printf();
    
    printf("\n%d", sum(a+1, b));
    printf(...., sum(a, c));  --> y = c (incompatibilità fra tipi) -> y = 12 (troncato)
}

------
AREA DATI
  area globale:
a | 10 |
b | 11 |
c | 12.5 |
è sempre attiva

- main:
! null !
| codice |
è sempre attiva

- sum:
| x 10| non ancora attualizzati
| y 11| 
| temp 21 | definito localmente
| codice |
questa area di dati viene allocalata solamente quando main invoca la funzione e quando return ripassa il controllo al main, esso viene deallocato.


----

passaggio dei parametri formali nella funzione che viene richiamata ->
esecuzione della prima istruzione e il main si sospende in modo asincrono

return ritorna il valore e ripassa il controllo al main. sum(a,b) viene sostituito dal valore generato dalla sottofunzione.

è possibile richiamare una sottofunzione all'interno di una sottofunzione

1. numero parametri formali uguale al numero di quelli attuali in ogni esecuzione;
2. corrispondenza posizionale tra parametri formali e attuali;
3. il nome di un parametro formale può NON corrispondere a quello del corrispondente parametro attuale
4. tipo dei parametri formali: tipo base, identificatore di tipo (per ora NON la sua definizione) e puù essere una struct, un puntatore (NO array
 -> non c'è il passaggio naturale di un vettore perché la sua copia è esoso memoricamente);
5. modalità di passaggio passaggio parametri è per VALORE: ogni coppia parametro attuale/formale rispetta
le regle di compatibilità e di conversione per gli assegnamenti;
6. parametro attuale puù essere una costante, variabile o espressione
7. sottoprogramma restituisce un valore al sottoprogramma chiamante di tipo base, struct, puntatore, void (NO array)

scanf e printf sono sottoprogrammi, non caratteri speciali

- ordine di valutazione dei parametri è implementation dependent
es. printf("...%d...&d", n++, n*4)) 
dipende dagli ambienti di programmazione

Un sottoprogramma che non restituisce un valore di ritorno al programma chiamante:
- f(x) va definita prima della sua invocazione
void f(int x) {...}
conseguenze:
- return non ha il valore da restituire:
  : "return valore" in generale genera warning del compilatore -> valore eliminato
  : "return" è opzionale (la funzione comunque termina quando incontra la "{") -> lo si può omettere


(sum a, b) procedurale: non ha senso

x = printf //funzionale, restituisce